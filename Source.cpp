//utf-8

#include <iostream>
#include <fstream>
#include <string>
#include <cmath>

// допустимая неточность в вычислениях с double:
#define DOUBLE_EPSILON 1e-12

/*
	класс векторов в трехмероном пространстве и базисов в пространстве
	рекомендую предварительно посмотреть файл "R3.h".
*/
//  Добавил операции R3[i] - чтение i-го элемента вектора,
//                   matrix[i] - чтение вектора - i-го столбца матрицы (удобно для получения v* - столбцов _M_)
#include "R3.h"  

using namespace std;

//функция, считывающая данные из 'configuration.file' из файла по его полному или относительному пути.
void READ(const char*);

//=================================================================================================================================================
//=================================================================================================================================================
//===============================БЛОК КОНСТАНТ=====================================================================================================

const double lam = 0.71073;      //Длина вволны рентгеновского источника, взвешанная MoKa = 2/3 MoKa1 + 1/3 MoKa2, в Ангстремах

/*
	Вывод дифракции в кристаллах
			  ↑
			   \         !!! принятое обозначение 2θ - угол между падающим и дифрагировавшим лучем
			θ / \
	================================
			θ \  A  / θ    |
				/|\        | d
			   / | \       |
	==========/==+==\===============
			 /   A   \
			/   /|\   \
		   /   /   \   \
		  /   / 2•θ'\   \  θ' = 90deg - θ
		 ↓   ↓   |   ↑   ↑
		k_diff   ↓s  k_inc (волновой вектор падающего излучения)

	s - вектор обратного пространства, s = _a * h + _b * k + _c * l и |s| = 1/d

	разность хода лучей должна быть кратна/равна λ = 2d•cos θ'
	
	 -> d = λ/2cos θ', |s| = 1/d,
	 cos θ' = λ|s|/2

	 sin θ  = λ|s|/2
*/

//Матрица ориентации { a, b, c }, все координаты в Ангстремах
matrix M = {
	{0, 0, 0}, // a
	{0, 0, 0}, // b
	{0, 0, 0}  // c
};

//hkl      
double h = 0.0, k = 0.0, l = 0.0;


//Определяем матрицу ориентации в ОБРАТНОМ ПРОСТРАНСТВЕ 
matrix _M_ = {
	{0, 0, 0},
	{0, 0, 0},
	{0, 0, 0}
	// a* b* c*
};


//=================================================================================================================================================
//=================================================================================================================================================
//=================================================================================================================================================


//MAIN
int main(int argn, char* argv[]) {  
	if (argn == 1) READ("configuration.file");   //нет дополнительных аргументов - считываем матрицу ориентации и hkl из configuration.file в текущей папкe
	else {
		cout << argn << " parameters: [0] = " << argv[0] << ", [1] = " << argv[1] << ";" << endl;
		READ(argv[1]);  //считываем матрицу ориентации и hkl из файл, указанного вторым параметром 
	}

	M = _M_._M_();    //находим матрицу ориентации в "прямом" пространстве (пространстве объекта)
	// !!! cтроки матрицы M - вектора элементарной ячейки могут быть использованы для получения линейных и угловых параметров элементарной ячейки

	R3 k_inc = { 1 / lam, 0.0, 0.0 };                   // волновой вектор падающего излучения

	//ВРОДЕ БЫ МЫ ДОМНОЖАЕМ СТРОКИ, А НЕ СТОЛБЦЫ _M_[0] != _M_.a
	R3 s = _M_.a * h + _M_.b * k + _M_.c * l;    // вектор обратного пространства s(hkl) (разностный вектор рассеянного и падающего излучения)
	R3 k_diff = s + k_inc;                          // волновой вектор дифрагировавшего излучения
	
	if (abs(k_diff.length() - k_inc.length()) > DOUBLE_EPSILON) {
		cout << "s(" << h << "." << k << "." << l << ") for non-rotated crystal do not correspond to ellastic scattering condition!" << endl;
		// не выполняется условие упругого рассеяния |k_inc| = |k_diff|
		// говорят "s находится в неотражающем положении"
		// ЗАДАЧА1: найти все такие повороты кристалла (== вектора s) вокруг вертикальной оси,
		//          чтобы условие упругого рассеяния выполнялось, либо определить, что это невозможно.
	}
	else {
		// чудесное совпадение! s "в отражающем положении" без всякого поворота образца!
		cout << "s(" << h << "." << k << "." << l << ") is in diffraction position for non-rotated crystal !" << endl;
	}

	//sin th не может быть по модулю больше единицы!
	if (abs(lam * s.length() / 2) > 1)
		cout << "|sin th| >1 diffraction doesn't valid!\n";

		cout << "sin th = " << lam * s.length() / 2 << endl;

	//Task 1
	{
		/*Используя стереометрию, получаем, что если в сферических координатах s(hkl) задаётся углами "alpha" и "beta"
			и если угол между k_inc и s(hkl) равен 'gamma', то
					 ↑
			        /
		     |   * /|.
		     |*   / | .
		     | B /  |  . Gamma
		     |  /  * \  .
			 | / *  A \ .
			 |/________\.___k_inc___\
									/

			cos_gamma = sin_beta *( 1-2sin^2(alpha/2) )

					  //видно, что "gamma" меняется от PI/2 - "betha" до PI/2 + "beta"
					  //если (th')  не входит в промежуток gamma - отражающего положения не добиться изменением "alpha"
					  //th принадлежит (-beta ; +beta);
		*/
		double sin_beta = sqrt(1 - (s.z / s.length())*(s.x/s.length()));
		double sin_th = lam * s.length() / 2;

			//	s находится в отражающем положении, если gamma = th', cos th' = sin th

		double alpha_требуемое = 2 * asin(sqrt(0.5 * (1 - sin_th / sin_beta)));   //sin th = λ|s|/2

		double alpha_начальное = phi({ s.x, s.y, 0 }, { 1, 0, 0 });

			//тогда определяем кратчайший угол поворота 

		double delta = (s.y >= 0) ?  // в направлении tth
			+((alpha_требуемое) - (alpha_начальное)) :
			-((alpha_требуемое) - (alpha_начальное));

		cout << "Rotate on " << rad_to_degrees(delta) << " degrees, please\n";

		//матрица ориентации обратного пространства после поворота
		matrix _M_rotated = _M_ * matrix({ { cos(delta), sin(delta), 0.0},
									       {-sin(delta), cos(delta), 0.0},
									       {        0.0,        0.0, 1.0} });                     

		matrix M_rotated = _M_._M_();
		R3 s_rotated = _M_rotated.a * h + _M_rotated.b * k + _M_rotated.c * l;   //координаты вектора обратного пространства в новой матрице ориентации
		k_diff = k_inc + s_rotated;

		cout << "_M_ rotated : \n" <<_M_rotated << endl;


			// ЗАДАЧА2: для возможных поворотов найти направление (alpha, beta) векторов дифрагировавшено излучения -
			//          в этих направлениях (при соответствующем повороте) образца будут наблюдаться дифракционные пики.

	}
	

	
	// лабораторная система координат +x - вдоль пучка, +z - вертикально вверх, +y - до правой тройки (x8 - вглубь кабинета, Duo - к дверцам кабинета)
	// направления углов вращения при остальных нулевых углах:  tth (twice theta), omega - +z, phi - -z, chi - +x(?)

	//угол горизонтального поворота (в экваториальной плоскости xy) в сферических координатах для вектора s
	// !!! не очень информативно, лучше посчитать для  k_diff при s "в отражающем положении"
	

	cout << "  a* = " << _M_.a << endl;  // столбцы матрицы ориентации - вектора обратной решетки
	cout << "  b* = " << _M_.b << endl;
	cout << "  c* = " << _M_.c << endl;

	cout << "s(" << h << "." << k << "." << l << ") : " << s << endl;

	return 0;
}


//функция считывает матрицу ориентации и hkl с из файла "PATH\\configuration.file"
void READ(const char* path_configuration_file)
{
	ifstream in(path_configuration_file);
	if (!in.is_open()) {
		cerr << "CONFIG FILE NOT FOUND!\n";
	}
	{ string s; std::getline(in >> s, s); }   // "//матрица ориентации"
	// матрица ориентации (UB-matrix) описывает базис обратной решетки
	in >> _M_;

	{ string s; std::getline(in >> s, s); }   // "s(hkl)"
	in >> h >> k >> l;
	in.close();
}
