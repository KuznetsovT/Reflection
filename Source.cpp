// после правки ВЮ 23.10.2019
// ввести нумерацию версий?

#include <iostream>
#include <fstream>
#include <string>
#include <cmath>

// допустимая неточность в вычислениях с double:
#define DOUBLE_EPSILON 1e-12

/*
	класс векторов в трехмероном пространстве и базисов в пространстве
	рекомендую предварительно посмотреть файл "R3.h".
*/
//  Добавил операции R3[i] - чтение i-го элемента вектора,
//                   matrix[i] - чтение вектора - i-го столбца матрицы (удобно для получения v* - столбцов _M_)
#include "R3.h"  

using namespace std;

//функция, считывающая данные из 'configuration.file' из файла по его полному (!!!) или относительному пути.
void READ(const char*);

//=================================================================================================================================================
//=================================================================================================================================================
//===============================БЛОК КОНСТАНТ=====================================================================================================

const double lam = 0.71073;      //Длина вволны рентгеновского источника, взвешанная MoKa = 2/3 MoKa1 + 1/3 MoKa2, в Ангстремах

/*
	Вывод дифракции в кристаллах
			  ↑
			   \         !!! принятое обозначение 2θ - угол между падающим и дифрагировавшим лучем
			θ / \
	================================
			θ \  A  / θ    |
				/|\        | d
			   / | \       |
	==========/==+==\===============
			 /   A   \
			/   /|\   \
		   /   /   \   \
		  /   / 2•θ'\   \  θ' = 90deg - θ
		 ↓   ↓   |   ↑   ↑
		k_diff   ↓s  k_inc (волновой вектор падающего излучения)

	s - вектор обратного пространства, s = _a * h + _b * k + _c * l и |s| = 1/d

	разность хода лучей должна быть кратна/равна λ = 2d•cos θ'
	!!! λ->lam θ->th  - иначе в некоторых компиляторах возникают ошибки!
	 -> d = λ/2cos θ', |s| = 1/d,
	 cos θ' = λ|s|/2
	 sin θ  = λ|s|/2
*/

//Матрица ориентации { a, b, c }, все координаты в Ангстремах
matrix M = {
	{0, 0, 0}, // a
	{0, 0, 0}, // b
	{0, 0, 0}  // c
};

//'координаты' площади 'hkl'            !!! почему площади ???
double h = (double)0, k = (double)0, l = (double)0;
// явное привидение типов делается для переменных, для констант есть более простые способы указать тип:
// (double) 0 == 0.0; (float) 0 == 0.0f; (long double) 0 == 0.0l

//Находим матрицу ориентации в ОБРАТНОМ ПРОСТРАНСТВЕ !!! не находим, а определяем...
matrix _M_ = {
	{0, 0, 0},
	{0, 0, 0},
	{0, 0, 0}
	//       a* b* c*
};


//=================================================================================================================================================
//=================================================================================================================================================
//=================================================================================================================================================


//MAIN
int main(int argn, char* argv[]) {  // аргументы, передаваемые программе при вызове - удобный способ управления ее поведением !!!
	if (argn == 1) READ("configuration.file");   //нет дополнительных аргументов - считываем матрицу ориентации и hkl из configuration.file в текущей папкe
	else {
		// при вызове из командной строки "prog.exe dat_file_name" argn = 2, argv[0] = "prog.exe", argv[1] = "dat_file_name"
		// VisualC можно настроить на передачу аргументов вызываемой программе.
		cout << argn << " parameters: [0] = " << argv[0] << ", [1] = " << argv[1] << ";" << endl;
		READ(argv[1]);  //считываем матрицу ориентации и hkl из файл, указанного вторым параметром           !!!
	}
	//	READ("C:\\Users\\yater\\source\\repos\\Reflection\\configuration.file");   //считываем матрицу ориентации и hkl	READ("C:\\Users\\yater\\source\\repos\\Reflection\\configuration.file");   //считываем матрицу ориентации и hkl

	M = _M_._M_();                                                             //находим матрицу ориентации в "прямом" пространстве (пространстве объекта)
	// !!! cтроки матрицы M - вектора элементарной ячейки могут быть использованы для получения линейных и угловых параметров элементарной ячейки

	R3 k_inc = { 1 / lam, 0.0, 0.0 };                   // волновой вектор падающего излучения
	R3 s = _M_[0] * h + _M_[1] * k + _M_[2] * l;    // вектор обратного пространства s(hkl) (разностный вектор рассеянного и падающего излучения)
	R3 k_diff = s + k_inc;                          // волновой вектор дифрагировавшего излучения
	if (abs(k_diff.length() - k_inc.length()) > DOUBLE_EPSILON) {
		cout << "s(" << h << "." << k << "." << l << ") for non-rotated crystal do not correspond to ellastic scattering condition!" << endl;
		// не выполняется условие упругого рассеяния |k_inc| = |k_diff|
		// говорят "s находится в неотражающем положении"
		// ЗАДАЧА1: найти все такие повороты кристалла (== вектора s) вокруг вертикальной оси,
		//          чтобы условие упругого рассеяния выполнялось, либо определить, что это невозможно.
		// ЗАДАЧА2: для возможных поворотов найти направление (alpha, beta) векторов дифрагировавшено излучения -
		//          в этих направлениях (при соответствующем повороте) образца будут наблюдаться дифракционные пики.
	}
	else {
		// чудесное совпадение! s "в отражающем положении" без всякого поворота образца!
		cout << "s(" << h << "." << k << "." << l << ") is in diffraction position for non-rotated crystal !" << endl;
	}

	double sin_th = lam * s.length() / 2;             // !!! половинный угол между k_inc и k_diff, когда кристалл находится в отражающем положении
	// !!! а что, если sin_th оказался <-1 или >1?

	// лабораторная система координат +x - вдоль пучка, +z - вертикально вверх, +y - до правой тройки (x8 - вглубь кабинета, Duo - к дверцам кабинета)
	// направления углов вращения при остальных нулевых углах:  tth (twice theta), omega - +z, phi - -z, chi - +x(?)

	//угол горизонтального поворота (в экваториальной плоскости xy) в сферических координатах для вектора s
	// !!! не очень информативно, лучше посчитать для  k_diff при s "в отражающем положении"
	double alpha = (s.y >= 0) ?  // в направлении tth
		phi({ s.x, s.y, 0 }, { 1, 0, 0 }) :
		-phi({ s.x, s.y, 0 }, { 1, 0, 0 });

	//угол восхождения над экваториальной плоскостью s
	// !!! отклонение от экваториальной плоскости наглядней связывается с возможностью попадания данного отражения в детектор, чем угол с осью +z
	// !!! не очень информативно, лучше посчитать для k_diff при s "в отражающем положении"
//	double beta = asin((s.operator^({ 0,0,1 }) / s.length()));
	double beta = PI / 2 - asin(s.z / s.length());

	cout << "  a* = " << _M_[0] << endl;  // столбцы матрицы ориентации - вектора обратной решетки
	cout << "  b* = " << _M_[1] << endl;
	cout << "  c* = " << _M_[2] << endl;

	cout << "s(" << h << "." << k << "." << l << ") : " << s << endl;
	cout << "alpha(s) : " << rad_to_degrees(alpha) << " degrees\nbeta(s) : "
		<< rad_to_degrees(beta) << " degrees " << endl;

	cout << "2θ : " << 2 * rad_to_degrees(asin(sin_th)) << endl;

	return 0;
}


//функция считывает матрицу ориентации и hkl с из файла "PATH\\configuration.file"
void READ(const char* path_configuration_file)
{
	ifstream in(path_configuration_file);
	{ string s; std::getline(in >> s, s); }   // "//матрица ориентации"
	// !!! принятая матрица ориентации (UB-matrix) описывает базис обратной решетки
	in >> _M_;
	// !!! было бы здорово предусмотреть возвожность чтения нескольких hkl - на будущее...
	{ string s; std::getline(in >> s, s); }   // "//координаты плоскости d(hkl)"
	in >> h >> k >> l;
	in.close();
}
