//utf-8

#include <iostream>
#include <fstream>
#include <string>
#include <cmath>
#include <clocale>


/*
	класс векторов в трехмероном пространстве и базисов в пространстве
	рекомендую предварительно посмотреть файл "R3.h".
*/

#include "R3.h"  

using namespace std;

//функция, считывающая данные из 'configuration.file' из файла по его полному или относительному пути.
void READ(const char*);

//=================================================================================================================================================
//=================================================================================================================================================
//===============================БЛОК КОНСТАНТ=====================================================================================================

const double lam = 0.71073;      //Длина вволны рентгеновского источника, взвешанная MoKa = 2/3 MoKa1 + 1/3 MoKa2, в Ангстремах
const R3 k_inc = { 1 / lam, 0.0, 0.0 };    // волновой вектор падающего излучения
/*
	Вывод дифракции в кристаллах
              ↑
               \         !!! принятое обозначение 2θ - угол между падающим и дифрагировавшим лучем
            θ / \
    ================================
            θ \  A  / θ    |
                /|\        | d
               / | \       |
    ==========/==+==\===============
             /   A   \
            /   /|\   \
           /   /   \   \
          /   / 2•θ'\   \  θ' = 90deg - θ
         ↓   ↓   |   ↑   ↑
        k_diff   ↓s  k_inc (волновой вектор падающего излучения)

	s - вектор обратного пространства, s = _a * h + _b * k + _c * l и |s| = 1/d

	разность хода лучей должна быть кратна/равна λ = 2d•cos θ'
	
	 -> d = λ/2cos θ', |s| = 1/d,
	 cos θ' = λ|s|/2

	 sin θ  = λ|s|/2
*/

//Матрица ориентации { a, b, c }, все координаты в Ангстремах
matrix M = {
	{0, 0, 0}, // a
	{0, 0, 0}, // b
	{0, 0, 0}  // c
};

//hkl      
double h = 0.0, k = 0.0, l = 0.0;


//Определяем матрицу ориентации в ОБРАТНОМ ПРОСТРАНСТВЕ 
matrix _M_ = {
	{0, 0, 0},
	{0, 0, 0},
	{0, 0, 0}
	// a* b* c*
};


//=================================================================================================================================================
//=================================================================================================================================================
//=================================================================================================================================================


//MAIN
int main(int argn, char* argv[]) {  
	if (argn == 1) READ("configuration.file");   //нет дополнительных аргументов - считываем матрицу ориентации и hkl из configuration.file в текущей папкe
	else READ(argv[1]);                          //считываем матрицу ориентации и hkl из файл, указанного вторым параметром 

	M = _M_._M_();    //находим матрицу ориентации в "прямом" пространстве (пространстве объекта)
	cout << endl << M << endl;
	cout << M.a.length() << " " << M.b.length() << " " << M.c.length() << endl;

	

	R3 s = _M_.a * h + _M_.b * k + _M_.c * l;    // вектор обратного пространства s(hkl) (разностный вектор рассеянного и падающего излучения)
	R3 k_diff = s + k_inc;                          // волновой вектор дифрагировавшего излучения
	cout << "k_inc len : " << k_inc.length() << " vs k_dif len " << k_diff.length() << endl;


	//sin th не может быть по модулю больше единицы!
	if (abs(lam * s.length() / 2) > 1) {
		cout << "|sin th| >1 diffraction doesn't valid!\n";
		return 0;
	}
	cout << "sin th = " << lam * s.length() / 2 << endl;


	//Task 1
	{
		/*Используя стереометрию, получаем, что если в сферических координатах s(hkl) задаётся углами "Al" и "Bt"
			и если угол между k_inc и s(hkl) равен (PI-'Gm'), то
                         ↑s(hkl)
                        /
                 |   * /|.
                 |*   / | .
                 |Bt /  |  . Gm 
                 |  /  * \  .
                 | / * Al \ .
    ____k_inc___\|/________\.______\   x
                /                  /

			cos Gm = sin Bt *( 1-2sin^2(Al/2) )

					  //видно, что "Gm" меняется от PI/2 - "Bt" до PI/2 + "Bt"
					  //если (th')  не входит в промежуток (PI/2-Bt; Pi/2+Bt) - отражающего положения не добиться изменением "alpha"
					  //th принадлежит (-Bt; +Bt);
		*/
		double sin_Bt = sin(Beta(s));
		double sin_th = lam * s.length() / 2;

		if (abs(sin_th) > abs(sin_Bt)) {
			cout << "Diffraction is not possible with this Beta!\n";
		}

			//	s находится в отражающем положении, если σ =PI-th', cos th' = sin th

		double Al_требуемое = 2 * asin(sqrt(0.5 * (1 + sin_th / sin_Bt)));   //sin th = λ|s|/2

		double Al_начальное = phi({ s.x, s.y, 0 }, { 1, 0, 0 });

			//тогда определяем кратчайший угол поворота 

		double delta = (s.y >= 0) ?  // в направлении tth
			+((Al_требуемое) - (Al_начальное)) :
			-((Al_требуемое) - (Al_начальное));

		cout << "Rotate Alpha " << rad_to_degrees(delta) << " degrees, please\n";

	/*	//матрица ориентации обратного пространства после поворота
		matrix _M_rotated = _M_ * matrix({ { cos(delta), sin(delta), 0.0},
									       {-sin(delta), cos(delta), 0.0},
									       {        0.0,        0.0, 1.0} });                     
	
		matrix M_rotated = _M_._M_();
		R3 s_rotated = _M_rotated.a * h + _M_rotated.b * k + _M_rotated.c * l;   //координаты вектора обратного пространства в новой матрице ориентации
		k_diff = k_inc + s_rotated;

		cout << "_M_ rotated : \n" <<_M_rotated << endl;
		cout << "k_inc len : " << k_inc.length() << " vs k_dif len " << k_diff.length() << endl;
	*/
	}

	return 0;
}


//функция считывает матрицу ориентации и hkl с из файла "PATH\\configuration.file"
void READ(const char* path_configuration_file)
{
	ifstream in(path_configuration_file);
	if (!in.is_open()) {
		cerr << "CONFIG FILE NOT FOUND!\n";
	}
	{ string s; std::getline(in >> s, s); }   // "//матрица ориентации"
	// матрица ориентации (UB-matrix) описывает базис обратной решетки
	in >> _M_;

	{ string s; std::getline(in >> s, s); }   // "s(hkl)"
	in >> h >> k >> l;
	in.close();
}
